/**   
 * Copyright 2011 The Buzz Media, LLC
 * Additional work in this class Copyright 2009 Matthias Kaeppler
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.thebuzzmedia.common.crypto;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import com.thebuzzmedia.common.charset.EncodingUtils;
import com.thebuzzmedia.common.escape.PercentEscaper;
import com.thebuzzmedia.common.util.Base64;

/**
 * Class used to provide OAuth-compatible functionality around the construction
 * of a signature base string and eventual signing of that string with a secret
 * key and an optional secret token key to generate an HMAC as defined by <a
 * href="http://tools.ietf.org/html/rfc5849#section-3.4">Section 3.4</a> of the
 * OAuth spec.
 * <p/>
 * The value generated by this class by way of one of the <code>sign(...)</code>
 * methods is meant to be used as the <code>oauth_signature</code> value in an
 * OAuth-compliant API call or as the signature for any other API using the same
 * methods for generating an HMAC to verify client calls.
 * <p/>
 * Using HMACs to secure HTTP-based web APIs is commonly used when <a href=
 * "http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/"
 * >designing secure web-based APIs</a>.
 * <p/>
 * Since the OAuth spec clearly defines the process for normalizing, combining
 * and generating an HMAC from all these common query values, many web APIs
 * decide to simply follow the specification in this one regard (Section 3.4)
 * and use the same method for HMAC generation. So this class will make working
 * with APIs, following the OAuth spec with regards to signature/HMAC
 * generation, easier to write.
 * <p/>
 * This class can be used in a builder-pattern method, specifying the different
 * values to be signed on the fly or all passed to the constructor. This was
 * done for convenience.
 * <p/>
 * To ensure compliance with OAuth's unique encoding requirements (similar to <a
 * href="http://tools.ietf.org/html/rfc3629">RFC-3629</a> with 3 minor
 * modifications) this class utilizes an embedded copy of the
 * <code>PercentEscaper</code> from the <a
 * href="http://code.google.com/p/google-api-java-client/">Google API Client
 * Library</a> without adding the 240kb dependency to this library.
 * 
 * @author Riyad Kalla (software@thebuzzmedia.com)
 * @since 2.3
 */
public class OAuthSigner {
	/**
	 * All <code>String[]</code> data structures referenced by this class are
	 * meant to be of length 2, with 'name' in the 0th index position and
	 * 'value' in the 1st index position.
	 * <p/>
	 * This is a constant used to define the name's index, <code>0</code>.
	 */
	public static final int NAME_INDEX = 0;

	/**
	 * All <code>String[]</code> data structures referenced by this class are
	 * meant to be of length 2, with 'name' in the 0th index position and
	 * 'value' in the 1st index position.
	 * <p/>
	 * This is a constant used to define the value's index, <code>1</code>.
	 */
	public static final int VALUE_INDEX = 1;

	private static final PercentEscaper ENCODER = new PercentEscaper("-._~",
			false);
	private static final ParameterComparator COMPARATOR = new ParameterComparator();

	/**
	 * Used to define the different strengths of hashing algorithms this class
	 * supports being used to hash the resultant signature base string.
	 */
	public enum Algorithm {
		MD5("HmacMD5", "MD5"), SHA1("HmacSHA1", "SHA-1"), SHA256("HmacSHA256",
				"SHA-256"), SHA512("HmacSHA512", "SHA-512");

		private static final Map<String, Algorithm> FRIENDLY_NAME_MAP = new HashMap<String, OAuthSigner.Algorithm>(
				13);

		static {
			FRIENDLY_NAME_MAP.put(MD5.friendlyName, MD5);
			FRIENDLY_NAME_MAP.put(SHA1.friendlyName, SHA1);
			FRIENDLY_NAME_MAP.put(SHA256.friendlyName, SHA256);
			FRIENDLY_NAME_MAP.put(SHA512.friendlyName, SHA512);
		}

		public static Algorithm forFriendlyName(String friendlyName) {
			return FRIENDLY_NAME_MAP.get(friendlyName);
		}

		public String getName() {
			return name;
		}

		public String getFriendlyName() {
			return friendlyName;
		}

		/**
		 * Defined to match the "algorithm" argument understood by the
		 * {@link Mac} class in the JDK.
		 */
		private String name;
		private String friendlyName;

		private Algorithm(String name, String friendlyName) {
			this.name = name;
			this.friendlyName = friendlyName;
		}
	}

	private String requestMethod;
	private String baseURI;
	private List<String[]> paramList;

	public OAuthSigner() {
		// default constructor
	}

	public OAuthSigner(String requestMethod, String requestURL,
			Map<String, String[]> paramMap, ParamFilter filter)
			throws IllegalArgumentException, URISyntaxException {
		requestMethod(requestMethod).baseURI(requestURL).params(paramMap,
				filter);
	}

	public OAuthSigner(String requestMethod, String requestURL,
			List<String[]> paramList, ParamFilter filter)
			throws IllegalArgumentException, URISyntaxException {
		requestMethod(requestMethod).baseURI(requestURL).params(paramList,
				filter);
	}

	/**
	 * Resets the state of the signer so it can be reused.
	 */
	public void reset() {
		requestMethod = null;
		baseURI = null;

		if (paramList != null) {
			paramList.clear();
			paramList = null;
		}
	}

	/**
	 * Used to set the required "request method" as defined by <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.1"> Section
	 * 3.4.1.1</a> of the OAuth spec.
	 * 
	 * @param requestMethod
	 *            The method name (e.g. GET, PUT, POST, DELETE, HEAD, OPTIONS,
	 *            etc.) used to make the request.
	 * 
	 * @return a reference to this signer with the <code>requestMethod</code>
	 *         property correctly set.
	 * 
	 * @throws IllegalArgumentException
	 *             if <code>requestMethod</code> is <code>null</code>, empty or
	 *             cannot be successfully URL encoded.
	 */
	public OAuthSigner requestMethod(String requestMethod)
			throws IllegalArgumentException {
		if (requestMethod == null || requestMethod.length() == 0)
			throw new IllegalArgumentException(
					"requestMethod cannot be null or empty");

		try {
			this.requestMethod = ENCODER.escape(requestMethod.toUpperCase());
		} catch (Exception e) {
			throw new IllegalArgumentException("requestMethod ["
					+ requestMethod + "] could not be URL encoded.", e);
		}

		return this;
	}

	/**
	 * Used to set the required "base string URI" as defined by <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.2">section
	 * 3.4.1.2</a> of the OAuth spec.
	 * <p/>
	 * This method parses the given request URL into a valid {@link URI} object
	 * and then assembles the "base String URI" exactly as required by the OAuth
	 * spec.
	 * <p/>
	 * Implementation logic for this method was copied from Matthias Kaeppler's
	 * <a href=
	 * "https://github.com/kaeppler/signpost/blob/master/signpost-core/src/main/java/oauth/signpost/signature/SignatureBaseString.java"
	 * >signpost</a> OAuth implementation.
	 * 
	 * @param requestURL
	 *            The request URL called by the client. This URL is intended to
	 *            be from the Servlet API's
	 *            <code>HttpServletRequest.getRequestURL()</code> method call
	 *            and not include any of the query string.
	 * 
	 * @return a reference to this signer with the <code>baseURI</code> property
	 *         correctly set.
	 * 
	 * @throws IllegalArgumentException
	 *             if <code>requestURL</code> is <code>null</code>, empty or
	 *             cannot be successfully URL encoded.
	 * @throws URISyntaxException
	 *             if an instance of {@link URI} cannot be cleanly created by
	 *             parsing the given <code>requestURL</code> provided.
	 */
	public OAuthSigner baseURI(String requestURL)
			throws IllegalArgumentException, URISyntaxException {
		if (requestURL == null || requestURL.length() == 0)
			throw new IllegalArgumentException(
					"requestURL cannot be null or empty");

		/*
		 * Code originated from Matthias Kaeppler's signpost impl:
		 * https://github.com
		 * /kaeppler/signpost/blob/master/signpost-core/src/main
		 * /java/oauth/signpost/signature/SignatureBaseString.java
		 */
		URI uri = new URI(requestURL);
		String scheme = uri.getScheme();

		if (scheme == null)
			scheme = "";
		else
			scheme = scheme.toLowerCase();

		String authority = uri.getAuthority().toLowerCase();
		boolean dropPort = (scheme.equals("http") && uri.getPort() == 80)
				|| (scheme.equals("https") && uri.getPort() == 443);

		if (dropPort) {
			// find the last : in the authority
			int index = authority.lastIndexOf(":");
			if (index >= 0) {
				authority = authority.substring(0, index);
			}
		}

		String path = uri.getRawPath();

		if (path == null || path.length() <= 0) {
			path = "/"; // conforms to RFC 2616 section 3.2.2
		}

		// we know that there is no query and no fragment here.
		try {
			this.baseURI = ENCODER.escape(scheme + "://" + authority + path);
		} catch (Exception e) {
			throw new IllegalArgumentException("requestURL [" + requestURL
					+ "] could not be successfully URL encoded.", e);
		}

		return this;
	}

	/**
	 * Used to set (and normalize) the parameters found in the given {@link Map}
	 * as outlined in <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2">Section
	 * 3.4.1.3.2</a> of the OAuth spec. This method eventually delegates to
	 * {@link #params(List, ParamFilter)}.
	 * <p/>
	 * Signature generation automatically skips pairings that have a null or
	 * empty name (empty values are accepted per the OAuth spec).
	 * <p>
	 * Setting parameters for a signature generation is optional. If parameters
	 * are excluded, then only the request method and base URI along with the
	 * secret key will be used to calculate the signature.
	 * 
	 * @param paramMap
	 *            A map of the parameter names and 1 or more values associated
	 *            with each name. This can be retrieved easily from the Servlet
	 *            API using the <code>ServletRequest.getParameterMap()</code>
	 *            API call on the server side.
	 * @param filter
	 *            An optional filter used to filter out unwanted parameter names
	 *            and values from the normalization and combination step used
	 *            when generating the signature. For example, skipping the
	 *            "oauth_signature" value on the server side when vetting a
	 *            client call.
	 * 
	 * @return a reference to this signer with the parameters correct set.
	 */
	public OAuthSigner params(Map<String, String[]> paramMap, ParamFilter filter) {
		if (paramMap == null || paramMap.isEmpty())
			return this;

		/*
		 * We use an array to store the interim list of name/value pairings and
		 * not a static array the same size of the map, because it is possible
		 * that the map contains a single name with multiple values that will be
		 * flattened out into n+1 values in the resulting paramList.
		 */
		this.paramList = new ArrayList<String[]>(paramMap.size());
		Iterator<Entry<String, String[]>> entries = paramMap.entrySet()
				.iterator();

		// Iterate over all the parameters
		while (entries.hasNext()) {
			Entry<String, String[]> entry = entries.next();
			String[] values = entry.getValue();

			// If there were no values, set to the empty string
			if (values == null || values.length == 0)
				values = new String[] { "" };

			String name = entry.getKey();

			// Process each value as a separate param.
			for (int i = 0; i < values.length; i++) {
				String value = values[i];

				// Filter name/value pair if filter provided.
				if (filter != null && !filter.include(name, value))
					continue;

				// Add the name/value pair to our list.
				paramList.add(new String[] { name, value });
			}
		}

		// Pass a null filter because we already did the filter work above.
		return params(paramList, null);
	}

	/**
	 * Used to set (and normalize) the parameters found in the given
	 * {@link List} as outlined in <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2">Section
	 * 3.4.1.3.2</a> of the OAuth spec.
	 * <p/>
	 * Each <code>String[]</code> is meant to be a single name/value pair where
	 * the name is at index position 0 and the value is at index position 1.
	 * <p/>
	 * Names with duplicate values will simply have multiple
	 * <code>String[]</code> values in the list, each with the same name but
	 * different values.
	 * <p/>
	 * Signature generation automatically skips pairings that have a null or
	 * empty name (empty values are accepted per the OAuth spec).
	 * <p>
	 * Setting parameters for a signature generation is optional. If parameters
	 * are excluded, then only the request method and base URI along with the
	 * secret key will be used to calculate the signature.
	 * 
	 * @param paramList
	 *            A list of name/value array pairs that are to be included in
	 *            the signature calculation.
	 * @param filter
	 *            An optional filter used to filter out unwanted parameter names
	 *            and values from the normalization and combination step used
	 *            when generating the signature. For example, skipping the
	 *            "oauth_signature" value on the server side when vetting a
	 *            client call.
	 * 
	 * @return a reference to this signer with the parameters correct set.
	 */
	public OAuthSigner params(List<String[]> paramList, ParamFilter filter) {
		if (paramList == null || paramList.isEmpty())
			return this;

		// Filter the param list if a filter was provided.
		if (filter != null) {
			for (int i = 0; i < paramList.size(); i++) {
				String[] pair = paramList.get(i);

				if (pair != null
						&& !filter.include(pair[NAME_INDEX], pair[VALUE_INDEX]))
					paramList.remove(i);
			}
		}

		/*
		 * Normalize name/value pairs according to OAuth spec:
		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
		 */
		for (int i = 0, size = paramList.size(); i < size; i++) {
			String[] pair = paramList.get(i);

			// Ensure the name is non-null or empty (value can be either)
			if (pair[NAME_INDEX] != null && pair[NAME_INDEX].length() > 0) {
				try {
					pair[NAME_INDEX] = ENCODER.escape(pair[NAME_INDEX]);

					// Ensure it is not null before encoding.
					if (pair[VALUE_INDEX] != null)
						pair[VALUE_INDEX] = ENCODER.escape(pair[VALUE_INDEX]);
				} catch (Exception e) {
					e.printStackTrace();
					// no-op, continue to next pair.
				}
			}
		}

		/*
		 * Sort the list of name/value pairs according to OAuth spec:
		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
		 */
		Collections.sort(paramList, COMPARATOR);
		this.paramList = paramList;

		return this;
	}

	/**
	 * Used to generate an OAuth-compliant signature with all the properties set
	 * on this signer and according to <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.2">Section 3.4.2</a>
	 * of the OAuth spec.
	 * 
	 * @param algorithm
	 *            The hashing algorithm to use to generate the MAC.
	 * @param secretKey
	 *            The secret key or "client shared secret" used to sign the
	 *            signature base string.
	 * 
	 * @return an OAuth-compliant signature for all the given properties set on
	 *         this signer.
	 * 
	 * @throws IllegalStateException
	 *             if the signer hasn't had the required properties set before
	 *             this method is called.
	 * @throws IllegalArgumentException
	 *             if <code>algorithm</code> is <code>null</code> or
	 *             <code>secretKey</code> is <code>null</code> or empty.
	 * @throws RuntimeException
	 *             if an exception occurs while trying to generate the MAC. The
	 *             caller should be prepared to handle this failure scenario.
	 */
	public String sign(Algorithm algorithm, String secretKey)
			throws IllegalStateException, IllegalArgumentException,
			RuntimeException {
		return sign(algorithm, secretKey, null);
	}

	/**
	 * Used to generate an OAuth-compliant signature with all the properties set
	 * on this signer and according to <a
	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.2">Section 3.4.2</a>
	 * of the OAuth spec.
	 * 
	 * @param algorithm
	 *            The hashing algorithm to use to generate the MAC.
	 * @param secretKey
	 *            The secret key or "client shared secret" used to sign the
	 *            signature base string.
	 * @param tokenKey
	 *            An optionally token key or "token shared secret" to be applied
	 *            to the MAC generation as well.
	 * 
	 * @return an OAuth-compliant signature for all the given properties set on
	 *         this signer.
	 * 
	 * @throws IllegalStateException
	 *             if the signer hasn't had the required properties set before
	 *             this method is called.
	 * @throws IllegalArgumentException
	 *             if <code>algorithm</code> is <code>null</code> or
	 *             <code>secretKey</code> is <code>null</code> or empty.
	 * @throws RuntimeException
	 *             if an exception occurs while trying to generate the MAC. The
	 *             caller should be prepared to handle this failure scenario.
	 */
	public String sign(Algorithm algorithm, String secretKey, String tokenKey)
			throws IllegalStateException, IllegalArgumentException,
			RuntimeException {
		if (requestMethod == null)
			throw new IllegalStateException(
					"Uninitialized Signer: Valid requestMethod has not been set.");
		if (baseURI == null)
			throw new IllegalStateException(
					"Uninitialized Signer: Valid baseURI has not been set.");

		if (algorithm == null)
			throw new IllegalArgumentException("algorithm cannot be null");
		if (secretKey == null || secretKey.length() == 0)
			throw new IllegalArgumentException(
					"secretKey cannot be null or empty");

		String paramString = null;
		StringBuilder buffer = new StringBuilder(256);

		// Process params if there are any set
		if (paramList != null && !paramList.isEmpty()) {
			/*
			 * Concatenate all name/value pairs together in name=value pairings,
			 * then append them all to each other using '&' separators as OAuth
			 * requires: http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
			 */
			for (int i = 0, size = paramList.size(); i < size; i++) {
				String[] pair = paramList.get(i);

				// Skip null or empty named pairs
				if (pair[NAME_INDEX] != null && pair[NAME_INDEX].length() > 0) {
					String value = "";

					if (pair[VALUE_INDEX] != null)
						value = pair[VALUE_INDEX];

					buffer.append(pair[NAME_INDEX]).append('=').append(value)
							.append('&');
				}
			}

			// Trim the last spurious '&' that was appended
			buffer.setLength(buffer.length() - 1);

			try {
				// Encode the entire string of params we just created
				paramString = ENCODER.escape(buffer.toString());

				// Reset the buffer
				buffer.setLength(0);
			} catch (Exception e) {
				throw new RuntimeException(
						"Unable to encode the generated parameter string: "
								+ buffer.toString(), e);
			}
		}

		/*
		 * Begin building the signature base string according to:
		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.1
		 */
		buffer.append(requestMethod).append('&');
		buffer.append(baseURI).append('&');
		buffer.append(paramString);

		byte[] hash = null;
		StringBuilder keyBuffer = new StringBuilder(64);

		try {
			/*
			 * Begin building the key signature according to:
			 * http://tools.ietf.org/html/rfc5849#section-3.4.2
			 */
			keyBuffer.append(ENCODER.escape(secretKey)).append('&');

			// Append tokenKey is included (3 legged OAuth)
			if (tokenKey != null)
				keyBuffer.append(ENCODER.escape(tokenKey));

			char[] charBuffer = new char[keyBuffer.length()];
			keyBuffer.getChars(0, charBuffer.length, charBuffer, 0);

			// String.getBytes does ISO-8859-1 conversion, we want UTF8.
			byte[] byteBuffer = EncodingUtils.encode(charBuffer);
			SecretKey key = new SecretKeySpec(byteBuffer, algorithm.name);
			Mac mac = Mac.getInstance(algorithm.name);

			// Init with the secret key.
			mac.init(key);

			charBuffer = new char[buffer.length()];
			buffer.getChars(0, charBuffer.length, charBuffer, 0);
			byteBuffer = EncodingUtils.encode(charBuffer);

			// Generate the actual HMAC signature.
			hash = mac.doFinal(byteBuffer);
		} catch (Exception e) {
			throw new RuntimeException("Unable to generate an "
					+ algorithm.name + " signature with the given values.", e);
		}

		String signature = null;

		try {
			/*
			 * Per the OAuth spec
			 * (http://tools.ietf.org/html/rfc5849#section-3.4.2) the hash must
			 * be Base64-encoded using a URL-safe variant of Base64
			 * (http://tools.ietf.org/html/rfc2045#section-6.8).
			 */
			signature = (hash == null ? null : Base64.encodeBytes(hash,
					Base64.URL_SAFE));
		} catch (Exception e) {
			throw new RuntimeException(
					"Unable to Base64 encode (URL safe) the given hash.", e);
		}

		return signature;
	}

	/**
	 * An interface used to describe a simple parameter filter that can be
	 * included along with a collection of parameters to include in the HMAC
	 * generation.
	 * <p/>
	 * It is the filter's job to reject parameters that <strong>should
	 * not</strong> be included in the generation, for example, if this code is
	 * running on the server side, you would want to exclude the OAuth
	 * <code>signature</code> that the client sent to you while recalculating
	 * the HMAC. Additionally, you would want to exclude any null or empty
	 * parameters that may have mistakeningly been set.
	 * 
	 * @author Riyad Kalla (software@thebuzzmedia.com)
	 */
	public interface ParamFilter {
		public boolean include(String name, String value);
	}

	/**
	 * Comparator used to sort the <code>String[]</code> of length 2 used by
	 * this API to represent a name/value pair.
	 * 
	 * @author Riyad Kalla (software@thebuzzmedia.com)
	 */
	static class ParameterComparator implements Comparator<String[]> {
		/**
		 * Used internally by {@link OAuthSigner} to sort the params before
		 * normalizing them according to the OAuth spec.
		 * <p/>
		 * Names are compared first and then values only if the names are equal.
		 * 
		 * @return <code>-1</code> if <code>param1</code> is &lt;
		 *         <code>param2</code>, <code>0</code> if both params are
		 *         considered equal or <code>1</code> if <code>param1</code> is
		 *         &gt; <code>param2</code>.
		 * 
		 * @throws RuntimeException
		 *             if any of the <code>String[]</code> processed have
		 *             lengths that are not equal to 2.
		 */
		public int compare(String[] param1, String[] param2)
				throws RuntimeException {
			// Begin with the assumption they are equal.
			int value = 0;

			// Only continue checking if they ARE NOT equal.
			if (param1 != param2) {
				if (param1 == null && param2 != null)
					value = -1;
				else if (param1 != null && param2 == null)
					value = 1;
				else {
					// Sanity-check
					if (param1.length != 2 && param2.length != 2)
						throw new RuntimeException(
								"String[] parameter values included in the parameterList have mismatching lengths. All String[] must be of length 2, with param name at index 0 and param value at index 1.");

					// First, compare the names.
					value = param1[NAME_INDEX].compareTo(param2[NAME_INDEX]);

					// Only if the names were the same, should we compare the
					// values.
					if (value == 0)
						value = param1[VALUE_INDEX]
								.compareTo(param2[VALUE_INDEX]);
				}

			}

			return value;
		}
	}
}